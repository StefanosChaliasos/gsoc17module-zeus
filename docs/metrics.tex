\documentclass{article}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}

\date{}
\begin{document}

\title{Metrics for the AsiaCrypt16 Implementation} 

\author{Vitalis Salis}

\maketitle
\begin{abstract}
	I have computed some metrics for the prototype implementation \cite{prototype} of a mixnet based
    on the shuffle argument proposed by Fauzi et al \cite{shufflearg}. The goal of these metrics
    is to identify aspects of the code that are slow and find suitable replacements
    for them.
\end{abstract}

\section{Introduction}

The prototype implementation of the mixnet proposed by Fauzi et al, produces multiple
implementation difficulties. On implementations of cryptographic protocols it is typical
to use C for your cryptographic computation. Yet the prototype is implemented using python,
so it has to switch between python and C for its computations. This is the real bottleneck
of the prototype and the reason some operations are slower than they should.

\section{Metrics}

I have compiled a list of metrics for the various operations of the prototype. As you see
most of the time is taken by the prover and the verifier, as expected, because these have
the most operations that produce a context switch between Python and C.

\begin{table}
\begin{tabular}{ |p{3cm}|p{5cm}|p{3cm}|  }
    \hline
    \multicolumn{3}{|c|}{Metrics}\\
    \hline
    Operation & Short Description & Time per 100 voters\\
    \hline
    Initialization & Creates the elliptic Curve and private keys & 364ms\\
    Encryption & Encrypts the votes & 674ms\\
    Random Permutations & Creates random numbers & 1ms\\
    Proof & The shuffle & 2085ms\\
    Verification & Verification of the shuffle & 2738ms\\
    Decryption & Decrypts the votes & 489ms\\
    \hline
\end{tabular}
\caption{Metrics}
\end{table}

The time taken by each of these operations is linear, meaning that for 200 votes
you just double the numbers on the above table.

\section{Solutions}

Since the real bottleneck are the context switches, the most obvious solutions is to
limit them. The prover and the verifier that take the most time, also have the most
loops that do a context switch for each voter. We can avoid that by using universal functions
provided by numpy\cite{numpy} to do vectorized operations.


\bibliographystyle{plain}
\bibliography{metrics}

\end{document} 
